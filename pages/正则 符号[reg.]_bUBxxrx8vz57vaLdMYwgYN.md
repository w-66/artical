# 正则 符号\[reg.]

[regular](regular_k8atgzRQhZor6FiNZLUVdq.md "regular")

***

-   正则 教程

    [https://www.freecodecamp.org/chinese/learn/javascript-algorithms-and-data-structures/#regular-expressions](https://www.freecodecamp.org/chinese/learn/javascript-algorithms-and-data-structures/#regular-expressions "https://www.freecodecamp.org/chinese/learn/javascript-algorithms-and-data-structures/#regular-expressions")
-   扩展正则符号`extended-regexp`：`+``|``()``{}``?`
-   正则默认

    匹配的贪婪性：尽可能的多匹配

    匹配的非贪婪性：尽可能的少匹配

#### \[reg.]符号的转义

`\\`

表示`\`

`\[`

表示\[

`\]`

表示]

`\n`

表示回车换行

`\t`

表示Tab键

`\(`

`\)`&#x20;

`\b`

匹配单词边界

`\<`

匹配左边界

`\>`

```纯文本
Regex syntax clashes (problems with backslashes)
     'sed' uses the POSIX basic regular expression syntax.  According to
     the standard, the meaning of some escape sequences is undefined in
     this syntax; notable in the case of 'sed' are '\|', '\+', '\?',
     '\`', '\'', '\<', '\>', '\b', '\B', '\w', and '\W'.
```

### 单正则表示符号

1.  `^`：匹配输入字符串的开始位置

    [^符号的用法](^符号的用法_gk4dUSGm4AkoprnHHvHNcK.md "^符号的用法")
    -   匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
2.  `$`行的边界，匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，\$ 也匹配 '\n' 或 '\r' 之前的位置。

    匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，\$ 也匹配 '\n' 或 '\r' 之前的位置。
3.  `.`(点)任意一个字符，匹配除换行符（\n、\r）之外的**任何单个字符**。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。
    -   转义`\.`表示字符串 `.`
    匹配除换行符（\n、\r）之外的**任何单个字符**。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。
4.  `*`(星号) 前一个匹配( 字符)连续出现0次及以上
    -   匹配前面的子表达式零次或多次。例如，zo\* 能匹配 "z" 以及 "zoo"。\* 等价于{0,}。
5.   字符集合。匹配所包含的任意一个字符。
    -   例如
        -   `[abc]` 可以匹配a或b或c的单个字符
        -   `[a-z]`表示单个小写字母
        -   `[A-Z]`表示单个大写字母
        -   `[a-Z]`表示匹配大小写字母
        -   `[0-9]`表示单个数字
        -   `[a-Z0-9]`表示单个大小写字母或数字
    -   中括号中的出现的在正则中是特殊字符而在这里，表示其本身字符，不具有特殊含义。例如`|`就表示其本身字符，`.`就是点
6.  `[^]`：`^`在中括号内开头表示取反、排除 \[]
7.  `+` 匹配前面的子表达式一次或多次

    例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。

    在egrep中直接使用。在grep中需要使用 `\+` 表示，或者`-E`。<`egrep -o [a-Z]+` | `grep -o -E [a-Z]+` | `grep -o -E [a-Z]\+`>

    匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
8.  `|` 在正则中表示 `或`
    -   匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
9.  `()`括号内的的内容被视作一个整体; 后向引用(反向引用[\[Linux\]sed](\[Linux]sed_k3UmJRASAQ3DbU8cr1Gabt.md "\[Linux]sed"))

    标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。
10. `{}`前面参数的匹配次数

    `{n}`

    n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。

    `{n,}`

    n 是一个非负整数。至少匹配n 次

    例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。`o{1,}` 等价于 `o+`。`o{0,}` 则等价于 `o*`。

    `{,m}`

    最多匹配m次。等价于`{0,m}`

    `{n,m}`

    m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
11. `?`匹配前一个字符匹配0次或者1次
    -   例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
    当该字符紧跟在任何一个其他限制符 (\*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
12. `(?P<name>…)`（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 *name* 来获取的
    1.  组合名必须是有效的[Python](Python_ifd8apTqYkKuJg39xs7qN8.md "Python")标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。一个符号组合同样是一个数字组合，就像这个组合没有被命名一样。
    2.  命名组合可以在三种上下文中引用。如果样式是 `(?P<quote>['"]).*?(?P=quote)` （也就是说，匹配单引号或者双引号括起来的字符串)：
        | 引用组合 "quote" 的上下文            | 引用方法                                                   |
        | ---------------------------- | ------------------------------------------------------ |
        | 在正则式自身内                      | \*   `(?P=quote)` (如示)&#xA;&#xA;\*   `\1`              |
        | 处理匹配对象 *m*                   | \*   `m.group('quote')
        `&#xA;\*   `m.end('quote')` (等) |
        | 传递到 `re.sub()` 里的 *repl* 参数中 | \*   `\g<quote>
        `&#xA;\*   `\g<1>
        `&#xA;\*   `\1`      |
13. `(?…)`这是个扩展标记法 （一个 `'?'` 跟随 `'('` 并无含义）
    1.  &#x20;`'?'` 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； `(?P<name>...)` 是唯一的例外。 以下是目前支持的扩展。
14. `(pattern)` 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 \$0…\$9 属性。要匹配圆括号字符，请使用 '\\(' 或 '\\)'。
15. `(?:pattern)`匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
16. `(?=pattern)`正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
17. `(?!pattern)`正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
18. `(?<=pattern)` 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。
19. `(?<!pattern)` 反向否定预查，与正向否定预查类似，只是方向相反。例如"(?\<!95
20. `\`转义; 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\\\' 匹配 "\\" 而 "\\(" 则匹配 "("。
21. `\w`匹配字母、数字、下划线。等价于'\[A-Za-z0-9\_]'。
22. `\b` 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
23. `\d`匹配一个数字字符。等价于 \[0-9]。
24. `\r`匹配一个回车符。等价于 \x0d 和 \cM。
25. `\f`匹配一个换页符。等价于 \x0c 和 \cL。
26. `\n`匹配一个换行符。等价于 \x0a 和 \cJ。
27. `\D`匹配一个非数字字符。等价于 \[^0-9]。
28. `\B`匹配非单词边界，一个零宽度断言，这与 `\b` 相反
    -   'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
29. `\cx`匹配由 x 指明的控制字符
    -   例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
30. `\s`匹配任何空白字符，包括空格、制表符、换页符等等。等价于 \[ \f\n\r\t\v]。
31. `\S`匹配任何非空白字符。等价于 \[^ \f\n\r\t\v]。
32. `\t`匹配一个制表符。等价于 \x09 和 \cI。
33. `\v`匹配一个垂直制表符。等价于 \x0b 和 \cK。
34. `\w`匹配字母、数字、下划线。等价于'\[A-Za-z0-9\_]'。
35. `\W`匹配非字母、数字、下划线。等价于 '\[^A-Za-z0-9\_]'。
36. `\Z`只匹配字符串尾
37. `\A`仅匹配字符串的开头。 当不在 `re.M`模式时，`\A` 和 `^` 实际上是相同的。 在 `MULTILINE` 模式中，它们是不同的: `\A` 仍然只在字符串的开头匹配，但 `^` 可以匹配在换行符之后的字符串内的任何位置。
38. `\xn`匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。
39. `\num`匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
40. `\n`标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
41. `\nm`标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
42. `\un`匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
43. `\nml`如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
44. `\1`反向引用backreference，它指代正则表达式中第一个捕获组（capturing group）所匹配到的内容

常用组合

1.  `[0-9]+`匹配连续的数字 \[`+`]

    `egrep -o [a-Z]+` | `grep -o -E [a-Z]+` | `grep -o -E [a-Z]\+`

    匹配所有连续的字母，并且独占一行
2.  `[^a-z]`负值字符范围。匹配任何不在指定范围内的任意字符。例如，'\[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 \[`[^]`]
3.  `^$` 空行；没有空格的空行
4.  `.*` 任意一个字符匹配多次 = 匹配所有字符；匹配任意字符

    `^.*t`匹配任意字符开头到匹配每行的最后一个t结束的字符串。([正则表达式的贪婪性](https://www.bilibili.com/video/BV1vR4y1c77v?p=5\&t=668.2 "正则表达式的贪婪性"))



1.  `^`
2.  `$`
3.  `.`(点)
4.  `*`(星号)
5.  `[^]`
6.  `+`
7.  `|`
8.  `()`
9.  `{}`
10. `?`
11. `(?…)`
12. `(?P<name>…)`
13. `(pattern)`
14. `(?:pattern)`
15. `(?=pattern)`
16. `(?!pattern)`
17. `(?<=pattern)`
18. `(?<!pattern)`
19. `\`
20. `\w`
21. `\b`
22. `\d`
23. `\r`
24. `\f`
25. `\n`
26. `\D`
27. `\B`
28. `\cx`
29. `\s`
30. `\S`
31. `\t`
32. `\v`
33. `\w`
34. `\W`
35. `\Z`
36. `\A`
37. `\xn`
38. `\num`
39. `\n`
40. `\nm`
41. `\un`
42. `\nml`
43. `\1`

常用组合

1.  `[0-9]+`
2.  `[^a-z]`
3.  `^$`
4.  `.*`







***







### 示例



-   示例1：`grep -E 'i(t|s)' regexp.txt`、`grep -E  'i[st]' regexp.txt` 匹配it 或者is。<[\[Linux\]grep](\[Linux]grep_s1VmEZHkPA58qZQ5Q1mqqh.md "\[Linux]grep")`-E`|[\[Linux\]egrep](\[Linux]egrep_kLWNtCFmd2pZJKdCzsbvsy.md "\[Linux]egrep") `()``|`>
    ```纯文本
    ubuntu@VM-16-5-ubuntu:~/myProgram$ grep -E 'i(t|s)' regexp.txt         
    - Seeing is believing
    - To be or not to be，that is the question. ——哈姆雷特
    - what's past is prologue. ——莎士比亚《暴风雨》
    - there is only one heroism in the world: to see the world as it is and to love it. ——罗曼罗兰《米开朗基罗》
    - It is so nice when you can sit with someone and not have to talk.  

    ubuntu@VM-16-5-ubuntu:~/myProgram$ grep -E  'i[st]' regexp.txt         
    - Seeing is believing
    - To be or not to be，that is the question. ——哈姆雷特
    - what's past is prologue. ——莎士比亚《暴风雨》
    - there is only one heroism in the world: to see the world as it is and to love it. ——罗曼罗兰《米开朗基罗》
    - It is so nice when you can sit with someone and not have to talk. 
    ```

***



正则表达式 - 元字符

####

| 非打印字符 | 描述                                                                                  |
| ----- | ----------------------------------------------------------------------------------- |
| `\cx` | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\f`  | 匹配一个换页符。等价于 \x0c 和 \cL。                                                             |
| `\n`  | 匹配一个换行符。等价于 \x0a 和 \cJ。                                                             |
| `\r`  | 匹配一个回车符。等价于 \x0d 和 \cM。                                                             |
| `\s`  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 \[ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。                |
| `\S`  | 匹配任何非空白字符。等价于 \[^ \f\n\r\t\v]。                                                      |
| `\t`  | 匹配一个制表符。等价于 \x09 和 \cI。                                                             |
| `\v`  | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                                                           |

#### 限定符`{n,m}`

```html
{n,m}
m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 {n,m}
```

|      |                                                                                                           |
| ---- | --------------------------------------------------------------------------------------------------------- |
| 字符   | 描述                                                                                                        |
| \*   | 匹配前面的子表达式零次或多次。例如，zo\* 能匹配 "z" 以及 "zoo"。\* 等价于{0,}。                                                       |
| +    | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。                                           |
| ?    | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。                   |
| {n}  | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。                                      |
| {n,} | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o\*'。 |
|      |                                                                                                           |

#### 懒惰限定符

|        |                  |
| ------ | ---------------- |
| 代码/语法  | 说明               |
| \*?    | 重复任意次，但尽可能少重复    |
| +?     | 重复1次或更多次，但尽可能少重复 |
| ??     | 重复0次或1次，但尽可能少重复  |
| {n,m}? | 重复n到m次，但尽可能少重复   |
| {n,}?  | 重复n次以上，但尽可能少重复   |

#### 定位符

|    |                                                                    |
| -- | ------------------------------------------------------------------ |
| 字符 | 描述                                                                 |
| ^  | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。  |
| \$ | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，\$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b | 匹配一个单词边界，即字与空格间的位置。                                                |
| \B | 非单词边界匹配。                                                           |

来自 <[https://www.runoob.com/regexp/regexp-syntax.html](https://www.runoob.com/regexp/regexp-syntax.html "https://www.runoob.com/regexp/regexp-syntax.html")>

## 常用的处理选项

|                               |                                                                                    |
| ----------------------------- | ---------------------------------------------------------------------------------- |
| 名称                            | 说明                                                                                 |
| IgnoreCase(忽略大小写)             | 匹配时不区分大小写。                                                                         |
| Multiline(多行模式)               | 更改^和的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) |
| Singleline(单行模式)              | 更改.的含义，使它与每一个字符匹配（包括换行符\n）。                                                        |
| IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由#标记的注释。                                                            |
| ExplicitCapture(显式捕获)         | 仅捕获已被显式命名的组。                                                                       |
