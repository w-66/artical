# \[对比]ntpd|ntpdate 同步网络时间

\[对比][Windows](Windows_naxTuYSGhtTRsChwqeti2D.md "Windows")|[Linux](Linux_gVG7ZedEwNpUe7fzyw66SJ.md "Linux")时间管理区别

在Windwos中，系统时间的设置很简单，界面操作，通俗易懂，而且设置后，重启，关机都没关系。系统时间会自动保存在BIOS时钟里面，启动计算机的时候，系统会自动在BIOS里面取硬件时间，以保证时间的不间断。但在Linux下，默认情况下，系统时间和硬件时间并不会自动同步。在Linux运行过程中，系统时间和硬件时间以异步的方式运行，互不干扰。硬件时间的运行，是靠BIOS电池来维持，而系统时间，是用CPU Tick来维持的。在系统开机的时候，会自动从BIOS中取得硬件时间，设置为系统时间。

关于[\[Linux\]ntp](\[Linux]ntp_dE135BKHdZdShZvxh3fNpo.md "\[Linux]ntp")与[\[Linux\]ntpdate](\[Linux]ntpdate_5Y6BCJkuyEcFJfFFAyj5X.md "\[Linux]ntpdate")区别的。如下所示所示：

使用之前得弄清楚一个问题，ntpd与ntpdate在更新时间时有什么区别。ntpd不仅仅是时间同步服务器，它还可以做客户端与标准时间服务器进行同步时间，而且是平滑同步，并非ntpdate立即同步，在生产环境中慎用ntpdate，也正如此两者不可同时运行。时钟的跃变，对于某些程序会导致很严重的问题。许多应用程序依赖连续的时钟——毕竟，这是一项常见的假定，即，取得的时间是线性的，一些操作，例如数据库事务，通常会地依赖这样的事实：时间不会往回跳跃。不幸的是，ntpdate调整时间的方式就是我们所说的”跃变“：在获得一个时间之后，ntpdate使用settimeofday(2)设置系统时间，这有几个非常明显的问题：

1.  这样做不安全。

    ntpdate的设置依赖于ntp服务器的安全性，攻击者可以利用一些软件设计上的缺陷，拿下ntp服务器并令与其同步的服务器执行某些消耗性的任务。

    由于ntpdate采用的方式是跳变，跟随它的服务器无法知道是否发生了异常（时间不一样的时候，唯一的办法是以服务器为准）。
2.  这样做不精确。

    一旦ntp服务器宕机，跟随它的服务器也就会无法同步时间。

    与此不同，ntpd不仅能够校准计算机的时间，而且能够校准计算机的时钟。
3.  这样做不够优雅。

    由于是跳变，而不是使时间变快或变慢，依赖时序的程序会出错（例如，如果ntpdate发现你的时间快了，则可能会经历两个相同的时刻，对某些应用而言，这是致命的）。因而，唯一一个可以令时间发生跳变的点，是计算机刚刚启动，但还没有启动很多服务的那个时候。其余的时候，理想的做法是使用ntpd来校准时钟，而不是调整计算机时钟上的时间。NTPD在和时间服务器的同步过程中，会把BIOS计时器的振荡频率偏差——或者说Local Clock的自然漂移(drift)——记录下来。这样即使网络有问题，本机仍然能维持一个相当精确的走时

ntpd与ntpdate

使用ntpd服务，要好于ntpdate加cron的组合。因为，ntpdate同步时间会造成时间的突变和跳跃，对一些依赖时间的程序和服务会造成影响。比如sleep，timer等。而且ntpd服务可以在修正时间的同时，修正CPU Tick。因此理想的做法为，在开机的时候，使用ntpdate强制同步时间，在其他时候使用ntpd服务来同步时间。

要注意的是，ntpd 有一个自我保护的机制：如果本机与上源时间相差太大，ntpd 不会运行时间同步操作，所以新设置的时间服务器一定要先 ntpdate 从上源取得时间初值, 然后启动 ntpd服务。ntpd服务运行后，先是每64秒与上源NTP服务器同步一次，根据每次同步时测得的误差值经复杂计算逐步调整自己的时间，随着误差减小，逐步增加同步的间隔。每次跳动，都会重复这个调整的过程。

